{
	"compiler": {
		"version": "0.8.26+commit.8a97fa7a"
	},
	"language": "Solidity",
	"output": {
		"abi": [
			{
				"inputs": [],
				"name": "num",
				"outputs": [
					{
						"internalType": "uint256",
						"name": "",
						"type": "uint256"
					}
				],
				"stateMutability": "view",
				"type": "function"
			},
			{
				"inputs": [],
				"name": "sender",
				"outputs": [
					{
						"internalType": "address",
						"name": "",
						"type": "address"
					}
				],
				"stateMutability": "view",
				"type": "function"
			},
			{
				"inputs": [
					{
						"internalType": "uint256",
						"name": "_num",
						"type": "uint256"
					}
				],
				"name": "setVars",
				"outputs": [],
				"stateMutability": "payable",
				"type": "function"
			}
		],
		"devdoc": {
			"kind": "dev",
			"methods": {},
			"version": 1
		},
		"userdoc": {
			"kind": "user",
			"methods": {},
			"notice": "delegate call delegatecall is same as call, which is the low level of address. when user A call contract B, contract C's function will be invoked normal call: -----             -----------             ----------- |userA| --call--> | contractB |  --call-->| contractC | -----             -----------             ----------- contex: B                 contex: C msg.sender: A             msg.sender: B msg.value: A              msg.value: B delegateCall: -----             -----------                     ----------- |userA| --call--> | contractB |  --delegateCall-->| contractC | -----             -----------                     ----------- contex: B                         contex: B msg.sender: A                     msg.sender: A msg.value: A                      msg.value: A Same as call(), delegateCall can be used as 'targetAddress'.delegatecall(byteCodes); bytecodes can be constructed as 'abi.encodeWithSignature('functionSignature',args)' fuctionSignature can be constructed as 'functionName(uint256,address)' etc. - different from call, delegatecall can define gas but cannot define ETH - notes: delegatecall have some security problems. when it is used, you need to ensure that current contract have the same variable structure as target constract and target constract is a safety constract. delegatecall mainly be used in below two scenerio 1. Proxy Contract: seprate storage contract from logic contract. we are going to save logic contract address and all variable in proxy contract, and we save logic in logic contract. when we are going to update, we just need to change the address in proxy contract. 2. EIP-2535 Diamonds: Diamonds is a standard which can build a smart contract system that can extend module in production environment.*",
			"version": 1
		}
	},
	"settings": {
		"compilationTarget": {
			"contracts/101+102.sol": "C"
		},
		"evmVersion": "cancun",
		"libraries": {},
		"metadata": {
			"bytecodeHash": "ipfs"
		},
		"optimizer": {
			"enabled": false,
			"runs": 200
		},
		"remappings": []
	},
	"sources": {
		"contracts/101+102.sol": {
			"keccak256": "0x4e5acb1dfea77cd1bcf6ebf518bd78ec829f4ab4184bcb3d7005bc74025c176b",
			"license": "MIT",
			"urls": [
				"bzz-raw://c4d8dead6fb34fb230f031a95c82e9447e0f5f1784a62f47ff2a0e0ff953c972",
				"dweb:/ipfs/QmUnD7xsj8MhXUpuUhWoy3y8evYfpDg53GXENwAudQ1fzy"
			]
		}
	},
	"version": 1
}