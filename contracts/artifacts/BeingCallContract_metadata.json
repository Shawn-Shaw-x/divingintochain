{
	"compiler": {
		"version": "0.8.21+commit.d9974bed"
	},
	"language": "Solidity",
	"output": {
		"abi": [
			{
				"anonymous": false,
				"inputs": [
					{
						"indexed": false,
						"internalType": "uint256",
						"name": "amount",
						"type": "uint256"
					},
					{
						"indexed": false,
						"internalType": "uint256",
						"name": "gas",
						"type": "uint256"
					}
				],
				"name": "Log",
				"type": "event"
			},
			{
				"stateMutability": "payable",
				"type": "fallback"
			},
			{
				"inputs": [],
				"name": "getBalance",
				"outputs": [
					{
						"internalType": "uint256",
						"name": "",
						"type": "uint256"
					}
				],
				"stateMutability": "view",
				"type": "function"
			},
			{
				"inputs": [],
				"name": "getX",
				"outputs": [
					{
						"internalType": "uint256",
						"name": "x",
						"type": "uint256"
					}
				],
				"stateMutability": "view",
				"type": "function"
			},
			{
				"inputs": [
					{
						"internalType": "uint256",
						"name": "x",
						"type": "uint256"
					}
				],
				"name": "setX",
				"outputs": [],
				"stateMutability": "payable",
				"type": "function"
			}
		],
		"devdoc": {
			"kind": "dev",
			"methods": {},
			"version": 1
		},
		"userdoc": {
			"kind": "user",
			"methods": {},
			"notice": "call() is low level function of address, it can be used to intereact with other contract. (bool,types) is it's returns 1. 'fallback()' and 'receive()' can be trigged by  call() when sedding ETH 2. invoked another contract by call in not recommand ,  because when you invoke another unsafe contract by 'call()', you are taking the initiative  - you should invoke another contract's function by invoking function after declaring varibale 3. we still can invoke another contract's function by 'call()' when we don't know other contract's source code or ABI. 4. contract'sAddress.call(bytes) is the rules. 'bytes' can be encoded by 'abi.encodeWithSignature()' example: abi.encodeWithSignature(\"functionSignatureString\", detailArgs);*",
			"version": 1
		}
	},
	"settings": {
		"compilationTarget": {
			"contracts/divingIntoChain.sol": "BeingCallContract"
		},
		"evmVersion": "shanghai",
		"libraries": {},
		"metadata": {
			"bytecodeHash": "ipfs"
		},
		"optimizer": {
			"enabled": false,
			"runs": 200
		},
		"remappings": []
	},
	"sources": {
		"contracts/divingIntoChain.sol": {
			"keccak256": "0xb8fb73b411be3843611aaeb6db887cb84c3884acac8529498f85ac7eb8c67980",
			"license": "MIT",
			"urls": [
				"bzz-raw://54b7310d4612f8268e12945a3746082ae01491fb77b0203dec3e0bb14c58fc2a",
				"dweb:/ipfs/QmeNNhoDopTFefSMRd55NWwwdG7m3PvJ1cjPE1XZpgZjTV"
			]
		}
	},
	"version": 1
}